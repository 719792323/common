## 什么是关系型数据库？

是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）

## 外键的保留和舍弃

* 缺点：

  1. **增加了复杂性：** a. **每次做 DELETE 或者 UPDATE 都必须考虑外键约束**，会导致开发的时候很痛苦, 测试数据极为不方便; b. 外键的主从关系是定的，假如那天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦。

  2. **增加了额外工作**：数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；（个人觉得这个不是不用外键的原因，因为即使你不使用外键，你在应用层面也还是要保证的。所以，我觉得这个影响可以忽略不计。）

  3. **对分库分表不友好**：因为分库分表下外键是无法生效的。

* 优点：

  1. 保证了数据库数据的一致性和完整性；
  2. 级联操作方便，减轻了程序代码量；

外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度，如果系统不涉及分库分表，并发量不是很高的情况还是可以考虑使用外键的。

## Drop、Delete、Truncate区别

- `drop`(丢弃数据): `drop table 表名` ，直接将表都删除掉，在删除表的时候使用。
- `truncate` (清空数据) : `truncate table 表名` ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。
- `delete`（删除数据） : `delete from 表名 where 列名=值`，删除某一行的数据，如果不加 `where` 子句和`truncate table 表名`作用类似。

`truncate` 和不带 `where`子句的 `delete`、以及 `drop` 都会删除表内的数据，但是 **`truncate` 和 `delete` 只删除数据不删除表的结构(定义)，执行 `drop` 语句，此表的结构也会删除，也就是执行`drop` 之后对应的表不复存在。**

## MySQL 字段类型

* 各字段类型长度是多少？

- **数值类型**：整型（TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT）、浮点型（FLOAT 和 DOUBLE）、定点型（DECIMAL）
- **字符串类型**：CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB 等，**最常用的是 CHAR 和 VARCHAR**。
- **日期时间类型**：YEAR、TIME、DATE、DATETIME 和 TIMESTAMP 等。

![MySQL 常见字段类型总结](https://oss.javaguide.cn/github/javaguide/mysql/summary-of-mysql-field-types.png)

------

### 整数类型的 UNSIGNED 属性有什么用？

MySQL 中的整数类型可以使用可选的 **UNSIGNED 属性来表示不允许负值的无符号整数**。使用 UNSIGNED 属性可以将正整数的上限提高一倍，因为它不需要存储负数值。

例如， TINYINT UNSIGNED 类型的取值范围是 0 ~ 255，而普通的 TINYINT 类型的值范围是 -128 ~ 127。INT UNSIGNED 类型的取值范围是 0 ~ 4,294,967,295，而普通的 INT 类型的值范围是 -2,147,483,648 ~ 2,147,483,647。

对于从 0 开始递增的 ID 列，使用 UNSIGNED 属性可以非常适合，因为不允许负值并且可以拥有更大的上限范围，提供了更多的 ID 值可用。

------

###  CHAR 和 VARCHAR 的区别是什么？

CHAR 和 VARCHAR 是最常用到的字符串类型，两者的主要区别在于：**CHAR 是定长字符串，VARCHAR 是变长字符串。**

**CHAR 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格（可以说会占满定义的长度）；VARCHAR 在存储时需要使用 1 或 2 个额外字节记录字符串的长度，检索时不需要处理**。

CHAR 更适合**存储长度较短或者长度都差不多的字符串**，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。**VARCHAR 类型适合存储长度不确定或者差异较大的字符串**，例如用户昵称、文章标题等。

CHAR(M) 和 VARCHAR(M) 的 M 都代表能够保存的字符数的最大值，无论是字母、数字还是中文，每个都只占用一个字符。

------

### DECIMAL 和 FLOAT/DOUBLE 的区别是什么？

DECIMAL 和 FLOAT 的区别是：**DECIMAL 是定点数，FLOAT/DOUBLE 是浮点数。DECIMAL 可以存储精确的小数值，FLOAT/DOUBLE 只能存储近似的小数值。**

DECIMAL 用于存储具有精度要求的小数，例如与货币相关的数据，可以避免浮点数带来的精度损失。

在 Java 中，MySQL 的 DECIMAL 类型对应的是 Java 类 `java.math.BigDecimal`。

------

### 为什么不推荐使用 TEXT 和 BLOB？

* TEXT和BLOB是定长还是变长（变长）？
* 临时表
* 该类型数据怎么指定索引

TEXT 类型类似于 CHAR（0-255 字节）和 VARCHAR（0-65,535 字节），但可以存储更长的字符串，即长文本数据，例如博客内容。

| 类型       | 可存储大小           | 用途           |
| ---------- | -------------------- | -------------- |
| TINYTEXT   | 0-255 字节           | 一般文本字符串 |
| TEXT       | 0-65,535 字节        | 长文本字符串   |
| MEDIUMTEXT | 0-16,772,150 字节    | 较大文本数据   |
| LONGTEXT   | 0-4,294,967,295 字节 | 极大文本数据   |

BLOB 类型主要用于存储二进制大对象，例如图片、音视频等文件。

| 类型       | 可存储大小 | 用途                     |
| ---------- | ---------- | ------------------------ |
| TINYBLOB   | 0-255 字节 | 短文本二进制字符串       |
| BLOB       | 0-65KB     | 二进制字符串             |
| MEDIUMBLOB | 0-16MB     | 二进制形式的长文本数据   |
| LONGBLOB   | 0-4GB      | 二进制形式的极大文本数据 |

在日常开发中，很少使用 TEXT 类型，但偶尔会用到，而 BLOB 类型则基本不常用。如果预期长度范围可以通过 VARCHAR 来满足，建议避免使用 TEXT。

**数据库规范通常不推荐使用 BLOB 和 TEXT 类型**，这两种类型具有一些缺点和限制，例如：

- 不能有默认值。
- 在使用临时表时无法使用内存临时表，只能在磁盘上创建**临时表**（《高性能 MySQL》书中有提到）。
- 检索效率较低。
- **不能直接创建索引，需要指定前缀长度**。
- 可能会消耗大量的网络和 IO 带宽。
- 可能导致表上的 DML 操作变慢。
- ……

------

### DATETIME 和 TIMESTAMP 的区别是什么？

* 如果要存储毫秒或者更精细的时间怎么办？（用自定义数值类型存储时间戳）

* **占用空间**

**TIMESTAMP 只需要使用 4 个字节的存储空间，但是 DATETIME 需要耗费 8 个字节的存储空间**。但是，这样同样造成了一个问题，Timestamp 表示的时间范围更小。

- DATETIME：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59
- Timestamp：1970-01-01 00:00:01 ~ 2037-12-31 23:59:59

* **时区**

**DateTime 类型是没有时区信息的（时区无关）** ，DateTime 类型保存的时间都是当前会话所设置的时区对应的时间。这样就会有什么问题呢？当你的时区更换之后，比如你的服务器更换地址或者更换客户端连接时区设置的话，就会导致你从数据库中读出的时间错误。

**Timestamp 和时区有关**。Timestamp 类型字段的值会随着服务器时区的变化而变化，自动换算成相应的时间，说简单点就是在不同时区，查询到同一个条记录此字段的值会不一样。

* **性能**

由于 TIMESTAMP 需要根据时区进行转换，所以从毫秒数转换到 TIMESTAMP 时，不仅要调用一个简单的函数，还要调用操作系统底层的系统函数。这个系统函数为了保证操作系统时区的一致性，需要进行加锁操作，这就降低了效率。DATETIME 不涉及时区转换，所以不会有这个问题。为了避免 TIMESTAMP 的时区转换问题，建议使用指定的时区，而不是依赖于操作系统时区。

关于两者的详细对比，请参考我写的[MySQL 时间类型数据存储建议](https://javaguide.cn/database/mysql/some-thoughts-on-database-storage-time.html)。

| 类型         | 存储空间 | 日期格式                       | 日期范围                                                     | 是否带时区信息 |
| ------------ | -------- | ------------------------------ | ------------------------------------------------------------ | -------------- |
| DATETIME     | 5~8 字节 | YYYY-MM-DD hh:mm:ss[.fraction] | 1000-01-01 00:00:00[.000000] ～ 9999-12-31 23:59:59[.999999] | 否             |
| TIMESTAMP    | 4~7 字节 | YYYY-MM-DD hh:mm:ss[.fraction] | 1970-01-01 00:00:01[.000000] ～ 2038-01-19 03:14:07[.999999] | 是             |
| 数值型时间戳 | 4 字节   | 全数字如 1578707612            | 1970-01-01 00:00:01 之后的时间                               | 否             |

MySQL 时间类型选择的详细介绍请看这篇：[MySQL 时间类型数据存储建议open in new window](https://javaguide.cn/database/mysql/some-thoughts-on-database-storage-time.html)。

### NULL 和 '' 的区别是什么？

* count(*)和count(列名)有什么区别

`NULL` 跟 `''`(空字符串)是两个完全不一样的值，区别如下：

- `NULL` 代表一个不确定的值,就算是两个 `NULL`,它俩也不一定相等。例如，**`SELECT NULL=NULL`的结果为 false**，但是在我们使用**`DISTINCT`,`GROUP BY`,`ORDER BY`时,`NULL`又被认为是相等的**。
- `''`的长度是 0，是不占用空间的，而`NULL` 是需要占用空间的。
- `NULL` 会影响**聚合函数**的结果。例如，**`SUM`、`AVG`、`MIN`、`MAX` 等聚合函数会忽略 `NULL`** 值。 `COUNT` 的处理方式取决于参数的类型。**如果参数是 `*`(`COUNT(*)`)，则会统计所有的记录数，包括 `NULL` 值；如果参数是某个字段名(`COUNT(列名)`)，则会忽略 `NULL` 值，只统计非空值的个数**。
- 查询 `NULL` 值时，必须使用 `IS NULL` 或 `IS NOT NULL` 来判断，而不能使用 =、!=、 <、> 之类的比较运算符。而`''`是可以使用这些比较运算符的。

------

### Boolean 类型如何表示？

MySQL 中没有专门的布尔类型，而是用 TINYINT(1) 类型来表示布尔值。TINYINT(1) 类型可以存储 0 或 1，分别对应 false 或 true。

## MySQL存储不同类别数据建议

1. **IP类型数据**

   可以将 IP 地址转换成整形数据存储，性能更好，占用空间也更小。

   MySQL 提供了两个方法来处理 ip 地址

   - `INET_ATON()`：把 ip 转为无符号整型 (4-8 位)
   - `INET_NTOA()` :把整型的 ip 转为地址

   插入数据前，先用 `INET_ATON()` 把 ip 地址转为整型，显示数据时，使用 `INET_NTOA()` 把整型的 ip 地址转为地址显示即可。
   
2. 日期数据

   建议使用TIMESTAMP、DATETIME、数值类型

3. 财务类型数据

   使用DECIMAL，decimal 类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节。并且，decimal 可用于存储比 bigint 更大的整型数据

   不过， 由于 decimal 需要额外的空间和计算开销，应该尽量只在需要对数据进行精确计算时才使用 decimal 。非精确要求使用float或者double

## MySQL架构

* mysql存储的引擎的对DDL的支持粒度是什么

**连接器：** 身份认证和权限相关(登录 MySQL 的时候)。

**查询缓存：** 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。

**分析器：** 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。

**优化器：** 按照 MySQL 认为最优的方案去执行。

**执行器：** 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。

**插件式存储引擎**：主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。（MySQL 存储引擎采用的是 **插件式架构** ，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。**存储引擎是基于表的，而不是数据库。**）

![img](https://oss.javaguide.cn/javaguide/13526879-3037b144ed09eb88.png)

## MyISAM和InnoDB比较

* 锁粒度：MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁
* 事务支持：MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。并且，InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）
* 外键支持：MyISAM 不支持，而 InnoDB 支持
* 崩溃后恢复：MyISAM 不支持，而 InnoDB 支持
* MVCC支持：MyISAM 不支持，而 InnoDB 支持
* 存储结构差别：虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。**InnoDB 引擎中，其数据文件本身就是索引文件**。相比 **MyISAM，索引文件和数据文件是分离的**，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录

## MySQL日志

* 错误日志 (error log) : 对 MySQL 的启动、运行、关闭过程进行了记录

* **二进制日志 (binary log，binlog)**：主要记录的是更改数据库数据的SQL 语句，记录了对 MySQL 数据库执行了更改的所有操作(数据库执行的所有 **DDL和 DML 语**)，包括表结构变更(CREATE、ALTER、DROP TABLE...) 、表数据修改 (INSERT、UPDATE.DELETE...)，**但不包括 SELECT、SHOW** 这类不会对数据库造成更改的操作。

  * binlog的格式

    * statement 模式：每一条会修改数据的sql都会被记录在binlog中，如inserts, updates, deletes.
    * Row 模式(推荐)：每一行的具体变更事件都会被记录在binlog中
    * Mixed 模式：Statement 模式和 Row 模式的混合。默认使用 Statement模式，少数特殊具体场景自动切换到 Row 模式

  * binlog的作用

    binlog 最主要的应用场景是 主从复制，主备、主主、主从都离不开binlog需要依靠 binlog 来同步数据，保证数据一致性。

    * 主库将数据库中数据的变化写入到 binlog
    * 从库连接主库
    * 从库会创建一个/0 线程向主库请求更新的 binlog
    * 主库会创建一个 binlog dump 线程来发送 binlog ，从库中的 I/0 线程负责接收
    * 从库的 I/0 线程将接收的 binlog 写入到 relay log 中
    * 从库的 SQL 线程读取 relay log 同步数据本地 (也就是再执行 SQL）

  * binlog刷盘时机

    对于InnoDB存储引擎而言，事务在执行过程中，会先把日志写入到 binlog cache 中，只有在事务提交的时候，才会把 binlog cache 中的日志持久化到磁盘上的 binlog 文件中。写入内存的速度更快，这样做也是为了效率考虑通过设置sync_binlog参数可以控制刷盘时机

    * 0：不去强制要求，由系统自行判断何时写入磁盘
    * 1：每次提交事务的时候都要将binlog写入磁盘
    * N：每 N 个事务，才会将binlog写入磁盘

  * 会新生成binlog的情况
    * MySQL停止后重启
    * 使用fluish logs命令
    * 当前binlog大小已经超过max_binlog_size

* 一般查询日志 (general query log)：已建立连接的客户端发送给MySQL 服务器的所有 SQL 记录，因为 SQL 的量比较大，默认是不开启的，也不建议开启。

* **慢查询日志 (slow query log)** : 执行时间超过long query time 秒钟的查询，解决 SQL 慢查询问题的时候会用到。

* **事务日志(redo log 和 undo log)** : redo log 是重做日志，undo log 是回滚日志

  https://www.yuque.com/snailclimb/mf2z3k/zr4kfk#256fef77

  * redolog

    MySQL InnoDB 引擎使用 redo log 来保证事务的持久性。**redo log 主要做的事情就是记录页的修改**，比如某个页面某个偏移量处修改了几个字节的值以及具体被修改的内容是什么。redo log 中的每一条记录包含了表空间号、数据页号、偏移量、具体修改的数据，甚至还可能会记录修改数据的长度(取决于redo log 类型)**在事务提交时会将 redo log 按照刷盘策略刷到磁盘上去**，这样即使MySQL 宕机了，重启之后也能恢复未能写入磁盘的数据，从而保证事务的持久性。也就是说，redo log 让 MySQL 具备了崩溃恢复能力。

    * redolog刷盘情况
      1. 事务提交时
      2. log buffer空间不足时
      3. 触发定期检查点时
      4. 后台刷新现场触发时
      5. 事务日志缓冲器满时
      6. MySQL正常关闭时
    * 什么情况redolog会丢失
      1. redo log 写入 log buffer 但还未写入 page cache ，此时数据库崩溃，就会出现数据丢失(刷盘策略 innodb_flush log at_trx_commit 的值为 0 时可能会出现这种数据丢失)
      2. redo log 已经写入 page cache 但还未写入磁盘，操作系统奔溃，也可能出现数据丢失(刷盘策略 innodb flush log at trx commit的值为2 时可能会出现这种数据丢失)
    * binlog和redolog区别
      * 使用区别：binlog 主要用于数据库还原，属于数据级别的数据恢复，主从复制是binlog 最常见的一个应用场景。redolog 主要用于保证事务的持久性，属于事务级别的数据恢复
      * 存在区别：redolog 属于InnoDB 引警特有的，binlog 属于所有存储引擎共有的
      * redolog 属于物理日志，主要记录的是某个页的修改。binlog 属于逻辑日志，主要记录的是数据库执行的所有 DDL和 DML 语句
      * 存储方式：binlog 通过追加的方式进行写入，大小没有限制。redo log 采用循环写的方式进行写入，大小固定，当写到结尾时，会回到开头循环写日志。

  * undolog

    每一个事务对数据的修改都会被记录到 undo log ，当执行事务过程中出现错误或者需要执行回滚操作的话，MySQL 可以利用 undo log 将数据恢复到事务开始之前的状态。**undo log 属于逻辑日志，记录的是 SQL 语句，比如说事务执行一条 DELETE语句，那undo log 就会记录一条相对应的 INSERT 语句**

    * undolog作用

      1. 保证事务的原子性

      2. MVCC的实现使用了undo log

         InnoDB存储引擎中 MVCC 的实现用到了 undo log 。当用户读取一行记录时若该记录已经被其他事务占用，当前事务可以通过undo log读取之前的行版本信息，以此实现非锁定读取。

* 中继日志(relay log) ：relay log 是复制过程中产生的日志，很多方面都跟 binary log 差不多。relay log 针对的是主从复制中的从库。

* DDL 日志(metadata log): DDL 语句执行的元数据操作。

## MySQL索引

**索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种`排序好`的数据结构。**

索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。

索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 **Innodb 还是 MyIsam，都使用了 B+树作为索引结构**。

* 索引优缺点

  * 优点
    - 使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。
    - 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性
  * 缺点
    - 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。
    - 索引需要使用物理文件存储，也会耗费一定空间

  注意：索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升或者性能不如全表扫描。

* 各类索引数据结构

  * hash

    * 介绍：MySQL 的 InnoDB 存储引擎不直接支持常规的哈希索引，但是，InnoDB 存储引擎中存在一种特殊的“自适应哈希索引”（Adaptive Hash Index），自适应哈希索引并不是传统意义上的纯哈希索引，而是结合了 B+Tree 和哈希索引的特点，以便更好地适应实际应用中的数据访问模式和性能需求。自适应哈希索引的每个哈希桶实际上是一个小型的 B+Tree 结构。这个 B+Tree 结构可以存储多个键值对，而不仅仅是一个键。这有助于减少哈希冲突链的长度，提高了索引的效率。关于 Adaptive Hash Index 的详细介绍，可以查看 [MySQL 各种“Buffer”之 Adaptive Hash Indexopen in new window](https://mp.weixin.qq.com/s/ra4v1XR5pzSWc-qtGO-dBg) 这篇文章。

    * hash的问题： Hash 索引**不支持顺序和范围查询**。假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。并且，每次 IO 只能取一个。

  * 二叉树查找树：**二叉查找树的性能非常依赖于它的平衡程度，这就导致其不适合作为 MySQL 底层索引的数据结构**

  * AVL树：由于 AVL 树需要频繁地进行旋转操作来保持平衡，因此会有较大的计算开销进而降低了查询性能。并且， 在使用 AVL 树时，每个树节点仅存储一个数据，而每次进行磁盘 IO 时只能读取一个节点的数据，如果需要查询的数据分布在多个节点上，那么就需要进行多次磁盘 IO。 **磁盘 IO 是一项耗时的操作，在设计数据库索引时，我们需要优先考虑如何最大限度地减少磁盘 IO 操作的次数。**实际应用中，AVL 树使用的并不多

  * 红黑树：和 AVL 树不同的是，红黑树并不追求严格的平衡，而是大致的平衡。正因如此，红黑树的查询效率稍有下降，因为红黑树的平衡性相对较弱，可能会导致树的高度较高，这可能会导致一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因。也正因如此，红黑树的插入和删除操作效率大大提高了，因为红黑树在插入和删除节点时只需进行 O(1) 次数的旋转和变色操作，即可保持基本平衡状态，而不需要像 AVL 树一样进行 O(logn) 次数的旋转操作。

  * B/B+树

    * B/B+区别

      1. **B 树的所有节点既存放键(key) 也存放数据(data)**，而 **B+树只有叶子节点存放 key 和 data**，其他内节点只存放 key
      2. B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点（**方便范围扫描**）
      3. B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显
      4. 在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可

      总结：存储结构上差别，B+树更适合范围查询

    * MySQL中的B+树区别：简单一句话就是索引和数据是否分离

      MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“**非聚簇索引（非聚集索引）**”。

      InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。

  * 索引划分

    * 存储方式划分

      1. 聚簇索引（聚集索引）：**索引结构和数据一起存放的索引**，InnoDB 中的主键索引就属于聚簇索引。

         **优点**：

         - **查询速度非常快**：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作。
         - **对排序查找和范围查找优化**：聚簇索引对于主键的排序查找和范围查找速度非常快。

         **缺点**：

         - **依赖于有序的数据**：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。
         - **更新代价大**：如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。

      2. 非聚簇索引（非聚集索引）：**索引结构和数据分开存放的索引**，`二级索引(辅助索引)就属于非聚簇索引`。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。

         **优点**：

         更新代价比聚簇索引要小 。非聚簇索引的更新代价就没有聚簇索引那么大了，非聚簇索引的叶子节点是不存放数据的

         **缺点**：

         - **依赖于有序的数据**:跟聚簇索引一样，非聚簇索引也依赖于有序的数据
         - **可能会二次查询(回表)**:这应该是非聚簇索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。

    * 应用方式划分

      1. 主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。

      2. 二级索引：**二级索引（Secondary Index）又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。**唯一索引，普通索引，前缀索引等索引属于二级索引

      3. 普通索引：仅加速查询。

      4. 唯一索引：加速查询 + 列值唯一（可以有 NULL）。

      5. **覆盖索引**：一个索引包含（或者说覆盖）所有需要查询的字段的值。

      6. **联合索引**：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。

         最左匹配原则：最左前缀匹配原则指的是，在使用联合索引时，**MySQL** 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 **`>`**、**`<`** ）才会停止匹配。对于 **`>=`**、**`<=`**、**`BETWEEN`**、**`like`** 前缀匹配的范围查询，并不会停止匹配。所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。[联合索引的最左匹配原则全网都在说的一个错误结论](https://mp.weixin.qq.com/s/8qemhRg5MgXs1So5YCv0fQ)

      7. 前缀索引：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符。

      8. 全文索引：对文本的内容进行分词，进行搜索。目前只有 `CHAR`、`VARCHAR` ，`TEXT` 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。

      9. 隐藏索引：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置），MySQL8之后支持。

      10. 降序索引：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引。另外，在 MySQL 8.x 版本中，不再对 GROUP BY 语句进行隐式排序。

      11. 函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。

  * 索引创建最佳实践

    * 选择合适的字段创建索引

      1. **不为 NULL 的字段**：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代
      2. **被频繁查询的字段**：我们创建索引的字段应该是查询操作非常频繁的字段
      3. **被作为条件查询的字段**：被作为 WHERE 条件查询的字段，应该被考虑建立索引
      4. **频繁需要排序的字段**：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间
      5. **被经常频繁用于连接的字段**：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率

    * 尽量不选择被频繁更新的字段作为索引

      虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了

    * 限制单表的索引数量

      索引并不是越多越好，建议单张表索引不超过 5 个！索引可以提高效率同样可以降低效率。

      索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。

      因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能

    * 尽量创建联合索引

      因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升

    * 避免创建冗余索引

      冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引

    * 字符串类型的字段使用前缀索引代替普通索引

      前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引

    * 避免索引失效

      1. 使用 `SELECT *` 进行查询; `SELECT *` 不会直接导致索引失效（如果不走索引大概率是因为 where 查询范围过大导致的），但它可能会带来一些其他的性能问题比如造成网络传输和数据处理的浪费、无法使用索引覆盖;

      2. 创建了组合索引，但查询条件未遵守最左匹配原则;
      3. 在索引列上进行计算、函数、类型转换等操作;
      4. 以 % 开头的 LIKE 查询比如 `LIKE '%abc';`;
      5. 查询条件中使用 OR，且 OR 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;
      6. IN 的取值范围较大时会导致索引失效，走全表扫描(NOT IN 和 IN 的失效场景相同);
      7. 发生[隐式转换](https://javaguide.cn/database/mysql/index-invalidation-caused-by-implicit-conversion.html)

    * 删除**长期**未使用的索引
    
      删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗。
  
      MySQL 5.7 可以通过查询 `sys` 库的 `schema_unused_indexes` 视图来查询哪些索引从未被使用。
    

## MySQL事务

1. 不可重复读和幻读区别

   - 不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；
   - 幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。

   幻读比不可重复读更难解决，**幻读需要序列化、可重复读前提下加表锁、可重复读前提下加Next key Lock**，不可重复读可以使用读锁或写锁或者MVCC解决

2. MySQL的事务控制方案

   * 锁

     * 锁类型：共享锁、排它锁、表锁、行锁、意向锁、间隙锁

   * MVCC

     **MVCC** 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。

     MVCC 在 MySQL 中实现所依赖的手段主要是: **隐藏字段、read view、undo log**

3. MySQL的隔离级别实现方式

   SERIALIZABLE 隔离级别是通过锁来实现的，READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的。不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。
   
## MVCC分析

* [RR与RC读分析](https://blog.csdn.net/qq_41361506/article/details/108538702)
* [MVCC会产生幻读](https://blog.csdn.net/EGXXM/article/details/132332881)
* [NextKey Lock锁范围](https://segmentfault.com/a/1190000040129107)

### 1. 多版本控制

MVCC 是一种并发控制机制，用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性。它是通过在每个数据行上维护多个版本的数据来实现的。当一个事务要对数据库中的数据进行修改时，MVCC 会为该事务创建一个数据快照，而不是直接修改实际的数据行

1. MVCC读操作

   **当一个事务执行读操作时，它会使用快照读取**。快照读取是基于事务开始时数据库中的状态创建的，因此事务不会读取其他事务尚未提交的修改。具体工作情况如下：

   - 对于读取操作，**事务会查找符合条件的数据行，并选择符合其事务开始时间的数据版本进行读取**。
   - 如果某个数据行有多个版本，事务会选择不晚于其开始时间的最新版本，确保事务只读取在它开始之前已经存在的数据。
   - 事务读取的是快照数据，因此其他并发事务对数据行的修改不会影响当前事务的读取操作。

2. MVCC写（INSERT、UPDATE、DELETE）

   **当一个事务执行写操作时，它会生成一个新的数据版本**，并将修改后的数据写入数据库。具体工作情况如下：

   - 对于写操作，事务会为要修改的数据行创建一个新的版本，并将修改后的数据写入新版本。
   - 新版本的数据会带有当前事务的版本号，以便其他事务能够正确读取相应版本的数据。
   - 原始版本的数据仍然存在，供其他事务使用快照读取，这保证了其他事务不受当前事务的写操作影响。

3. 事物提交和回滚

   - 当一个事务提交时，它所做的修改将成为数据库的最新版本，并且对其他事务可见。
   - 当一个事务回滚时，它所做的修改将被撤销，对其他事务不可见。

4. 版本回收

   为了防止数据库中的版本无限增长，MVCC 会定期进行版本的回收。回收机制会删除已经不再需要的旧版本数据，从而释放空间。

   MVCC 通过创建数据的多个版本和使用快照读取来实现并发控制。读操作使用旧版本数据的快照，写操作创建新版本，并确保原始版本仍然可用。这样，不同的事务可以在一定程度上并发执行，而不会相互干扰，从而提高了数据库的并发性能和数据一致性。

### 2.锁定读与非锁定读



## MySQL锁

* [为什么 MySQL 的自增主键不单调也不连续](https://draveness.me/whys-the-design-mysql-auto-increment/)

1. **表锁和行锁区别**

   MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。

   行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。

   **表级锁：** MySQL 中锁定粒度最大的一种锁（全局锁除外），是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。

   **行级锁：** MySQL 中锁定粒度最小的一种锁，是 **针对索引字段加的锁** ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。

2. **行锁存在什么问题**

   * 全局加锁：InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行 `UPDATE`、`DELETE` 语句时，如果 `WHERE`条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁

3. **存在哪些行锁**

   * 一些大厂面试中可能会问到 Next-Key Lock 的加锁范围，这里推荐一篇文章：[MySQL next-key lock 加锁范围是什么？ - 程序员小航 - 2021](https://segmentfault.com/a/1190000040129107)

   InnoDB 行锁是通过对索引数据页上的记录加锁实现的，MySQL InnoDB 支持三种行锁定方式：

   - **记录锁（Record Lock）**：也被称为记录锁，属于单个行记录上的锁。
   - **间隙锁（Gap Lock）**：锁定一个范围，不包括记录本身。
   - **临键锁（Next-Key Lock）**：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。

   **在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。**

   * 共享锁：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）

   * 排它锁：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）

     注意：由于 MVCC 的存在，对于一般的 `SELECT` 语句，InnoDB 不会加任何锁。不过， 你可以通过以下语句显式加共享锁或排他锁。

     ```sql
     # 共享锁 可以在 MySQL 5.7 和 MySQL 8.0 中使用
     SELECT ... LOCK IN SHARE MODE;
     # 共享锁 可以在 MySQL 8.0 中使用
     SELECT ... FOR SHARE;
     # 排他锁
     SELECT ... FOR UPDATE;
     ```

   * 意向共享锁：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁

   * 意向排他锁：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。

     **意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享/排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。**
     
   * 自增锁：关系型数据库设计表的时候，通常会有一列作为自增主键。InnoDB 中的自增键会涉及一种比较特殊的表级锁— **自增锁（AUTO-INC Locks）** 

     如果一个事务正在插入数据到有自增列的表时，会先获取自增锁，拿不到就可能会被阻塞住。这里的阻塞行为只是自增锁行为的其中一种，可以理解为自增锁就是一个接口，其具体的实现有多种。具体的配置项为 `innodb_autoinc_lock_mode` （MySQL 5.1.22 引入），可以选择的值如下：

     | innodb_autoinc_lock_mode | 介绍                           |
     | :----------------------- | :----------------------------- |
     | 0                        | 传统模式                       |
     | 1                        | 连续模式（MySQL 8.0 之前默认） |
     | 2                        | 交错模式(MySQL 8.0 之后默认)   |

     交错模式下，所有的“INSERT-LIKE”语句（所有的插入语句，包括：`INSERT`、`REPLACE`、`INSERT…SELECT`、`REPLACE…SELECT`、`LOAD DATA`等）都不使用表级锁，使用的是轻量级互斥锁实现，多条插入语句可以并发执行，速度更快，扩展性也更好。

     **如果你MySQL 数据库有主从同步需求并且 Binlog 存储格式为 Statement 的话，不要将 InnoDB 自增锁模式设置为交叉模式，不然会有数据不一致性问题。这是因为并发情况下插入语句的执行顺序就无法得到保障。**

4. **当前读和快照读区别**

   > **快照读**（**一致性非锁**定读）就是单纯的 `SELECT` 语句，但**不包括**下面这两类 `SELECT` 语句：

   ```sql
   SELECT ... FOR UPDATE
   # 共享锁 可以在 MySQL 5.7 和 MySQL 8.0 中使用
   SELECT ... LOCK IN SHARE MODE;
   # 共享锁 可以在 MySQL 8.0 中使用
   SELECT ... FOR SHARE;
   
   ```

   快照即记录的历史版本，每行记录可能存在多个历史版本（多版本技术）。

   快照读的情况下，如果读取的记录正在执行 UPDATE/DELETE 操作，读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照。

   只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读：

   - **在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据**。
   - **在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本**。

   快照读比较适合对于数据一致性要求不是特别高且追求极致性能的业务场景

   >当前读（一致性**锁定读**）就是给行记录加 X 锁或 S 锁
   
   使用如下sql语句就会执行锁定读
   
   ```sql
   # 对读的记录加一个X锁
   SELECT...FOR UPDATE
   # 对读的记录加一个S锁
   SELECT...LOCK IN SHARE MODE
   # 对读的记录加一个S锁
   SELECT...FOR SHARE
   # 对修改的记录加一个X锁
   INSERT...
   UPDATE...
   DELETE...
   ```

## MySQL优化方案

1. **命名规范**

   * 所有数据库对象名称必须使用**小写字母并用下划线分割**

   * 所有数据库对象名称禁止使用 MySQL 保留关键字（**如果表名中包含关键字查询时，需要将其用单引号括起来**）

   * 数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符

   * **临时库表必须以 `tmp_` 为前缀并以日期为后缀，备份表必须以 `bak_` 为前缀并以日期 (时间戳) 为后缀**

   * 所有**存储相同数据的列名和列类型必须一致**（一般作为关联列，如果查询时关联列类型不一致会自动进行**数据类型隐式转换**，会造成列上的索引失效，导致查询效率降低）。

2. **数据库设计规范**

   * 引擎统一：没有特殊要求（即 InnoDB 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 InnoDB 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 InnoDB）
   * 数据库和表字符集统一：兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，**不同的字符集进行比较前需要进行转换会造成索引失效**，如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集。
   * 表和字段需添加注释：使用 comment 从句添加表和列的备注，从一开始就进行数据字典的维护
   * 表数据量控制：建议单表控制数据量500 万，过大会造成修改表结构，备份，恢复都会有很大的问题。可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小
   * 慎用分区表：分区表在物理上表现为多个文件，在逻辑上表现为一个表；谨慎选择分区键，跨分区查询效率可能更低；建议采用物理分表的方式管理大数据
   * 常使用的列放在同个表中

3. **字段设计规范**

   * 选择符合存储需求的最小数据类型：

     * **某些字符串可以转换成数字类型存储比如可以将 IP 地址转换成整型数据**
     * **对于非负型的数据 (如自增 ID,整型 IP，年龄) 来说,要优先使用无符号整型来存储**
     * **小数值类型（比如年龄、状态表示如 0/1）优先使用 TINYINT 类型**

   * 避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据

     * MySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型，如果查询中包含这样的数据，**在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行**。而且对于这种数据，MySQL 还是要进行二次查询，会使 sql 性能变得很差，但是不是说一定不能使用这样的数据类型。

       如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 `select *`而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询

     * **只能使用前缀索引**

       因为 MySQL 对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的

   * 避免使用ENUM类型

     - 修改 ENUM 值需要使用 ALTER 语句；
     - ENUM 类型的 **ORDER BY 操作效率低**，需要额外操作；
     - ENUM 数据类型存在一些限制比如建议不要使用数值作为 ENUM 的枚举值

   * 尽可能把所有列定义为 NOT NULL

     除非有特别的原因使用 NULL 值，应该总是让字段保持 NOT NULL。

     - 索引 NULL 列需要额外的空间来保存，所以要占用更多的空间；
     - 进行比较和计算时要对 NULL 值做特别的处理。

     [技术分享 | MySQL 默认值选型（是空，还是 NULL）](https://opensource.actionsky.com/20190710-mysql/)

   * 不使用字符串存日期

     对于日期类型来说， 一定不要用字符串存储日期。可以考虑 DATETIME、TIMESTAMP 和 数值型时间戳。

4. **索引设计要求**

   * 单表索引个数限制：建议单表索引不超过5个

   * 不使用全文索引

   * 每个表必须手动指定主键

   * 建议设置索引的列：

     * 出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列

     * 包含在 ORDER BY、GROUP BY、DISTINCT 中的字段

     * 多表 join 的关联列

   * 联合索引设置顺序

     * 区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）

     * 尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）

     * 使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）

     

## SQL优化方案

1. [sql优化](https://www.yuque.com/snailclimb/mf2z3k/abc2sv)
2. [mysql优化规范](https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html)
3. [索引失效情况](https://mp.weixin.qq.com/s/mwME3qukHBFul57WQLkOYg)